# 代码级性能优化建议清单

## 🎯 优先级说明
- 🔴 **高优先级** - 立即实施，显著性能提升
- 🟡 **中优先级** - 建议实施，适度性能提升  
- 🟢 **低优先级** - 可选实施，细节优化

---

## 1. 数据库/存储优化

### 🔴 使用MMKV替代SharedPreferences
**影响文件**: `Config.java`, `Status.java`, `DataStore.kt`

**当前问题**:
- SharedPreferences在主线程同步I/O
- 频繁读写导致卡顿

**优化方案**:
```kotlin
// 已使用MMKV，但需确保异步写入
DataStore.put("key", value, async = true)
```

**预期收益**: I/O性能提升5-10倍

---

### 🟡 批量写入优化
**影响文件**: `Status.java`

**优化建议**:
```java
// 优化前：多次单独保存
Status.save(userId, "energy", value1);
Status.save(userId, "coins", value2);
Status.save(userId, "items", value3);

// 优化后：批量保存
Status.batchSave(userId, mapOf(
    "energy" to value1,
    "coins" to value2,
    "items" to value3
));
```

---

## 2. 网络请求优化

### 🔴 实现请求去重机制
**影响文件**: `NewRpcBridge.java`

**优化方案**:
```java
// 新增请求去重缓存
private final ConcurrentHashMap<String, RpcEntity> pendingRequests = new ConcurrentHashMap<>();

public RpcEntity requestObject(RpcEntity rpcEntity, int tryCount, int retryInterval) {
    String requestKey = rpcEntity.getRequestMethod() + ":" + rpcEntity.getRequestData().hashCode();
    
    // 检查是否有相同请求正在进行
    RpcEntity pending = pendingRequests.get(requestKey);
    if (pending != null && !pending.isCompleted()) {
        return pending; // 复用进行中的请求
    }
    
    pendingRequests.put(requestKey, rpcEntity);
    try {
        return performRequest(rpcEntity, tryCount, retryInterval);
    } finally {
        pendingRequests.remove(requestKey);
    }
}
```

**预期收益**: 减少10-20%重复请求

---

### 🟡 HTTP连接池优化
**影响文件**: `NewRpcBridge.java`

**建议**:
- 复用HTTP连接，避免频繁建立连接
- 设置合理的连接超时时间
- 实现连接保活机制

---

## 3. 内存优化

### 🔴 对象池技术
**影响文件**: `AntForest.kt`, `RpcEntity.kt`

**优化方案**:
```kotlin
// 为频繁创建的对象实现对象池
object RpcEntityPool {
    private val pool = ArrayDeque<RpcEntity>(32)
    
    fun obtain(): RpcEntity {
        return pool.removeFirstOrNull() ?: RpcEntity()
    }
    
    fun recycle(entity: RpcEntity) {
        entity.reset()
        if (pool.size < 64) {
            pool.addLast(entity)
        }
    }
}
```

**预期收益**: 减少GC压力，降低30-40%对象分配

---

### 🟡 弱引用缓存
**影响文件**: `UserMap.java`, `IdMapManager.java`

**优化建议**:
```java
// 使用WeakHashMap存储不常用数据
private static final Map<String, WeakReference<UserInfo>> userCache = 
    Collections.synchronizedMap(new WeakHashMap<>());
```

---

## 4. 并发优化

### 🔴 减少锁争用
**影响文件**: `UserMap.java`, `Files.java`

**当前问题**:
```java
// 过度使用synchronized导致线程阻塞
public synchronized static void load(String userId) {
    // 长时间I/O操作
}
```

**优化方案**:
```java
// 使用读写锁，允许并发读取
private static final ReadWriteLock rwLock = new ReentrantReadWriteLock();

public static void load(String userId) {
    rwLock.writeLock().lock();
    try {
        // I/O操作
    } finally {
        rwLock.writeLock().unlock();
    }
}

public static String get(String key) {
    rwLock.readLock().lock();
    try {
        return data.get(key);
    } finally {
        rwLock.readLock().unlock();
    }
}
```

**预期收益**: 并发读取性能提升3-5倍

---

### 🟡 使用ConcurrentHashMap替代同步Map
**影响文件**: 多个文件

**查找并替换**:
```java
// 替换前
Collections.synchronizedMap(new HashMap<>())

// 替换后  
new ConcurrentHashMap<>()
```

---

## 5. 算法优化

### 🔴 能量收集排序优化
**影响文件**: `AntForest.kt`

**当前问题**: 每次都对全部好友排序

**优化方案**:
```kotlin
// 使用优先队列，仅维护Top-N
private val topEnergyUsers = PriorityQueue<UserEnergy>(100) { a, b ->
    b.predictedEnergy.compareTo(a.predictedEnergy)
}

fun addUser(userId: String, energy: Int) {
    if (topEnergyUsers.size < 100 || energy > topEnergyUsers.peek().energy) {
        topEnergyUsers.offer(UserEnergy(userId, energy))
        if (topEnergyUsers.size > 100) {
            topEnergyUsers.poll()
        }
    }
}
```

**预期收益**: 大数据集排序性能提升50-70%

---

### 🟡 JSON解析优化
**影响文件**: `JsonUtil.java`

**建议**:
```java
// 使用流式解析替代DOM解析（大JSON时）
JsonReader reader = new JsonReader(new StringReader(jsonString));
reader.setLenient(true);
// 逐个解析，避免一次性加载大对象
```

---

## 6. UI/日志优化

### 🟡 异步日志写入
**影响文件**: `Log.java`, `Logback.java`

**优化方案**:
```java
// 日志写入使用独立线程池
private static final ExecutorService logExecutor = 
    Executors.newSingleThreadExecutor(r -> {
        Thread t = new Thread(r, "LogWriter");
        t.setPriority(Thread.MIN_PRIORITY);
        return t;
    });

public static void record(String tag, String message) {
    logExecutor.execute(() -> {
        // 异步写入文件
        writeToFile(tag, message);
    });
}
```

---

### 🟢 减少日志输出
**全局优化**:

**建议**:
- 生产环境关闭DEBUG级别日志
- 使用条件编译`if (BuildConfig.DEBUG)`
- 避免在循环中打印日志

---

## 7. 特定场景优化

### 🔴 能量雨收集优化
**影响文件**: `EnergyRainCoroutine.kt`

**优化建议**:
```kotlin
// 使用协程并发收集，而非顺序收集
suspend fun collectEnergyRainConcurrent(bubbles: List<Bubble>) = coroutineScope {
    bubbles.map { bubble ->
        async(Dispatchers.IO) {
            collectBubble(bubble)
        }
    }.awaitAll()
}
```

**预期收益**: 能量雨收集速度提升3-5倍

---

### 🟡 好友列表缓存优化
**影响文件**: `AntForest.kt`

**优化方案**:
```kotlin
// 增量更新好友列表，而非每次全量获取
private var lastFriendListUpdate = 0L
private val cachedFriendList = ConcurrentHashMap<String, FriendInfo>()

fun getFriendList(): List<FriendInfo> {
    val now = System.currentTimeMillis()
    if (now - lastFriendListUpdate > 5 * 60 * 1000) { // 5分钟更新一次
        updateFriendList()
        lastFriendListUpdate = now
    }
    return cachedFriendList.values.toList()
}
```

---

## 8. 协程优化

### 🟡 使用结构化并发
**影响文件**: `AntForest.kt`, `ModelTask.kt`

**优化建议**:
```kotlin
// 使用supervisorScope处理独立任务
supervisorScope {
    friends.forEach { friend ->
        launch {
            try {
                collectEnergy(friend)
            } catch (e: Exception) {
                // 单个任务失败不影响其他任务
                Log.error(TAG, "收集${friend.name}能量失败", e)
            }
        }
    }
}
```

---

### 🟡 合理使用Dispatchers
**全局优化**:

**建议**:
```kotlin
// IO密集任务
launch(Dispatchers.IO) { }

// CPU密集任务
launch(Dispatchers.Default) { }

// UI操作（如果有）
launch(Dispatchers.Main) { }

// 自定义调度器（已优化）
launch(GlobalThreadPools.computeDispatcher) { }
```

---

## 9. 电池优化

### 🟡 智能唤醒策略
**影响文件**: `AlarmScheduler.kt`, `ApplicationHook.java`

**优化建议**:
```kotlin
// 避免频繁唤醒，合并唤醒时机
fun scheduleSmartWakeup(tasks: List<Task>) {
    val groupedTasks = tasks.groupBy { 
        // 将时间接近的任务分组（15分钟窗口）
        it.scheduledTime / (15 * 60 * 1000)
    }
    
    groupedTasks.forEach { (window, tasksInWindow) ->
        // 一次唤醒执行多个任务
        scheduleAlarm(window * 15 * 60 * 1000, tasksInWindow)
    }
}
```

**预期收益**: 减少20-30%唤醒次数

---

### 🟢 JobScheduler替代AlarmManager
**影响文件**: `AlarmScheduler.kt`

**建议** (Android 5.0+):
```kotlin
// 使用JobScheduler进行任务调度（更省电）
val jobScheduler = context.getSystemService(Context.JOB_SCHEDULER_SERVICE) as JobScheduler
val jobInfo = JobInfo.Builder(JOB_ID, componentName)
    .setPeriodic(15 * 60 * 1000) // 15分钟
    .setRequiredNetworkType(JobInfo.NETWORK_TYPE_ANY)
    .setPersisted(true)
    .build()
jobScheduler.schedule(jobInfo)
```

---

## 10. 网络流量优化

### 🟡 数据压缩
**影响文件**: `NewRpcBridge.java`

**建议**:
```java
// 请求/响应启用GZIP压缩
request.addHeader("Accept-Encoding", "gzip, deflate");
```

---

### 🟡 增量数据同步
**影响文件**: `Status.java`

**优化方案**:
```java
// 仅同步变更的数据，而非全量
public static void syncChanges() {
    Map<String, Object> changes = getChangedData();
    if (!changes.isEmpty()) {
        uploadChanges(changes);
        markAsSynced();
    }
}
```

---

## 📊 优化效果预测

| 优化项 | 难度 | 预期性能提升 | 实施优先级 |
|-------|-----|------------|-----------|
| RPC去重机制 | 中 | 10-20% | 🔴 高 |
| 对象池技术 | 中 | 15-25% | 🔴 高 |
| 读写锁优化 | 低 | 20-30% | 🔴 高 |
| 能量雨并发 | 低 | 200-400% | 🔴 高 |
| 异步日志 | 低 | 5-10% | 🟡 中 |
| 好友列表缓存 | 低 | 10-15% | 🟡 中 |
| JobScheduler | 中 | 20-30%电量 | 🟢 低 |

---

## 🛠️ 实施步骤建议

### 第一阶段 (1-2天)
1. ✅ RPC指数退避（已完成）
2. ✅ 并发数优化（已完成）
3. ✅ 锁优化（已完成）
4. ✅ 智能缓存（已完成）

### 第二阶段 (3-5天)
1. ⬜ RPC请求去重
2. ⬜ 对象池实现
3. ⬜ 读写锁替换
4. ⬜ 能量雨并发优化

### 第三阶段 (1周)
1. ⬜ 异步日志优化
2. ⬜ 好友列表增量更新
3. ⬜ 内存优化（弱引用）
4. ⬜ 电池优化

---

## 📝 注意事项

1. **测试覆盖**: 每项优化后需充分测试，避免引入Bug
2. **版本兼容**: 确保优化兼容不同Android版本
3. **性能监控**: 使用Profiler监控优化效果
4. **渐进式优化**: 一次实施1-2项优化，观察效果后再继续

---

**文档版本**: v1.0  
**创建日期**: 2025-10-18  
**维护者**: Performance Team
