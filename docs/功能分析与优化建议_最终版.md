# åŠŸèƒ½åˆ†æä¸ä¼˜åŒ–å»ºè®® - æœ€ç»ˆç‰ˆ

**åˆ†ææ—¥æœŸ**: 2025-10-19  
**åˆ†æå†…å®¹**: æ‰¾èƒ½é‡ä¸€é”®æ”¶å–ã€Android 11åå°å”¤é†’ã€åŠ¨æ€æ”¶å–ä¼˜åŒ–

---

## ğŸ“Š ç›®å½•

1. [æ‰¾èƒ½é‡ä¸€é”®æ”¶å–åŠŸèƒ½åˆ†æ](#1-æ‰¾èƒ½é‡ä¸€é”®æ”¶å–åŠŸèƒ½åˆ†æ)
2. [Android 11åå°å”¤é†’æ–¹æ¡ˆ](#2-android-11åå°å”¤é†’æ–¹æ¡ˆ)
3. [åŠ¨æ€æ”¶å–é—´éš”ä¼˜åŒ–](#3-åŠ¨æ€æ”¶å–é—´éš”ä¼˜åŒ–)
4. [å®æ–½å»ºè®®](#4-å®æ–½å»ºè®®)

---

## 1. æ‰¾èƒ½é‡ä¸€é”®æ”¶å–åŠŸèƒ½åˆ†æ

### 1.1 ç°æœ‰å®ç°

#### é…ç½®å¼€å…³
```kotlin
// AntForest.kt - Line 311-315
private var batchRobEnergy: BooleanModelField? = null

modelFields.addField(
    BooleanModelField(
        "batchRobEnergy",
        "ä¸€é”®æ”¶å– | å¼€å…³",
        false  // é»˜è®¤å…³é—­
    ).also { batchRobEnergy = it }
)
```

#### æ ¸å¿ƒé€»è¾‘ (Line 1822-1851)
```kotlin
private fun collectEnergy(
    userId: String?,
    userHomeObj: JSONObject?,
    bubbleIds: MutableList<Long>,
    fromTag: String?,
    skipPropCheck: Boolean = false
) {
    val bizType = "GREEN"
    if (bubbleIds.isEmpty()) return
    
    val isBatchCollect = batchRobEnergy!!.value
    
    if (isBatchCollect) {
        // ===== ä¸€é”®æ”¶å–æ¨¡å¼ =====
        var i = 0
        while (i < bubbleIds.size) {
            // æ¯æ‰¹æœ€å¤š6ä¸ªèƒ½é‡çƒ
            val subList = bubbleIds.subList(i, min(i + MAX_BATCH_SIZE, bubbleIds.size))
            
            collectEnergy(
                CollectEnergyEntity(
                    userId,
                    userHomeObj,
                    AntForestRpcCall.batchEnergyRpcEntity(bizType, userId, subList),
                    fromTag,
                    skipPropCheck
                )
            )
            i += MAX_BATCH_SIZE
        }
    } else {
        // ===== é€ä¸ªæ”¶å–æ¨¡å¼ =====
        for (id in bubbleIds) {
            collectEnergy(
                CollectEnergyEntity(
                    userId,
                    userHomeObj,
                    AntForestRpcCall.energyRpcEntity(bizType, userId, id),
                    fromTag,
                    skipPropCheck
                )
            )
        }
    }
}
```

#### RPCè°ƒç”¨ (AntForestRpcCall.java - Line 246)
```java
public static RpcEntity batchEnergyRpcEntity(
    String bizType, 
    String userId, 
    List<Long> bubbleIds
) throws JSONException {
    JSONObject arg = new JSONObject();
    arg.put("bizType", bizType);
    arg.put("bubbleIds", new JSONArray(bubbleIds));
    arg.put("userId", userId);
    
    return new RpcEntity(
        "alipay.antmember.forest.h5.collectEnergy",
        arg.toString()
    );
}
```

#### æ—¥å¿—æ˜¾ç¤º (Line 2625-2629)
```kotlin
val collectType = when (collectEnergyEntity.fromTag) {
    "takeLook" -> "æ‰¾èƒ½é‡ä¸€é”®æ”¶å–ï¸"
    "è¹²ç‚¹æ”¶å–" -> "è¹²ç‚¹ä¸€é”®æ”¶å–ï¸"
    else -> "ä¸€é”®æ”¶å–ï¸"
}
```

---

### 1.2 å·¥ä½œæµç¨‹

```
ç”¨æˆ·è§¦å‘æ”¶å–
    â†“
æ£€æŸ¥ batchRobEnergy å¼€å…³
    â†“
    â”œâ”€ å¼€å¯ï¼šä¸€é”®æ”¶å–æ¨¡å¼
    â”‚   â”œâ”€ å°†bubbleIdsåˆ†ç»„ï¼ˆæ¯ç»„æœ€å¤š6ä¸ªï¼‰
    â”‚   â”œâ”€ æ‰¹é‡è°ƒç”¨ batchEnergyRpcEntity
    â”‚   â””â”€ æ—¥å¿—æ˜¾ç¤º "æ‰¾èƒ½é‡ä¸€é”®æ”¶å–ï¸"
    â”‚
    â””â”€ å…³é—­ï¼šé€ä¸ªæ”¶å–æ¨¡å¼
        â”œâ”€ éå†æ¯ä¸ªbubbleId
        â”œâ”€ å•ä¸ªè°ƒç”¨ energyRpcEntity
        â””â”€ æ—¥å¿—æ˜¾ç¤º "æ‰¾èƒ½é‡æ”¶å–"
```

---

### 1.3 ä¼˜ç‚¹ä¸ç¼ºç‚¹

#### âœ… ä¼˜ç‚¹

1. **æ€§èƒ½ä¼˜åŒ–**
   - æ‰¹é‡æ”¶å–å‡å°‘RPCè°ƒç”¨æ¬¡æ•°
   - æ¯6ä¸ªçƒä¸€æ¬¡è°ƒç”¨ï¼Œæ•ˆç‡æå‡çº¦6å€
   - ç½‘ç»œå¼€é”€æ˜¾è‘—é™ä½

2. **ä»£ç ç»“æ„æ¸…æ™°**
   - å¼€å…³æ§åˆ¶ç®€å•ç›´è§‚
   - ä¸¤ç§æ¨¡å¼ç‹¬ç«‹å®ç°
   - æ˜“äºç»´æŠ¤å’Œæµ‹è¯•

3. **ç”¨æˆ·ä½“éªŒ**
   - æ—¥å¿—æ¸…æ™°æ ‡è¯†æ”¶å–æ–¹å¼
   - å¯è‡ªç”±åˆ‡æ¢æ¨¡å¼
   - é€‚åº”ä¸åŒç½‘ç»œç¯å¢ƒ

#### âŒ ç¼ºç‚¹ä¸æ”¹è¿›ç©ºé—´

1. **æ‰¹é‡å¤§å°å›ºå®š**
   ```kotlin
   // å½“å‰ï¼šå›ºå®šæ¯æ‰¹6ä¸ª
   const val MAX_BATCH_SIZE = 6
   
   // å»ºè®®ï¼šåŠ¨æ€è°ƒæ•´
   private fun calculateOptimalBatchSize(
       networkQuality: NetworkQuality,
       totalBubbles: Int
   ): Int {
       return when (networkQuality) {
           NetworkQuality.EXCELLENT -> min(10, totalBubbles) // ç½‘ç»œå¥½ï¼š10ä¸ª
           NetworkQuality.GOOD -> min(6, totalBubbles)       // ç½‘ç»œä¸€èˆ¬ï¼š6ä¸ª
           NetworkQuality.POOR -> min(3, totalBubbles)       // ç½‘ç»œå·®ï¼š3ä¸ª
       }
   }
   ```

2. **ç¼ºå°‘æ™ºèƒ½é‡è¯•**
   ```kotlin
   // å½“å‰ï¼šæ‰¹é‡å¤±è´¥åæ— ç‰¹æ®Šå¤„ç†
   
   // å»ºè®®ï¼šå¤±è´¥æ—¶é™çº§ä¸ºé€ä¸ªæ”¶å–
   if (isBatchCollect) {
       try {
           // å°è¯•æ‰¹é‡æ”¶å–
           collectBatch(subList)
       } catch (e: Exception) {
           Log.record(TAG, "æ‰¹é‡æ”¶å–å¤±è´¥ï¼Œé™çº§ä¸ºé€ä¸ªæ”¶å–")
           // é™çº§ä¸ºé€ä¸ªæ”¶å–
           for (id in subList) {
               collectSingle(id)
           }
       }
   }
   ```

3. **ç¼ºå°‘ç½‘ç»œè´¨é‡æ£€æµ‹**
   ```kotlin
   // å»ºè®®ï¼šæ ¹æ®ç½‘ç»œè´¨é‡è‡ªåŠ¨é€‰æ‹©æ¨¡å¼
   private fun shouldUseBatchMode(): Boolean {
       val configEnabled = batchRobEnergy!!.value
       if (!configEnabled) return false
       
       val networkQuality = detectNetworkQuality()
       return networkQuality != NetworkQuality.POOR
   }
   ```

4. **ç¼ºå°‘ç»Ÿè®¡å’Œåé¦ˆ**
   ```kotlin
   // å»ºè®®ï¼šæ·»åŠ æ€§èƒ½ç»Ÿè®¡
   data class CollectStats(
       var batchCount: Int = 0,
       var singleCount: Int = 0,
       var batchSuccess: Int = 0,
       var batchFail: Int = 0,
       var avgBatchTime: Long = 0,
       var avgSingleTime: Long = 0
   )
   
   fun printStats() {
       Log.record(TAG, """
           æ”¶å–ç»Ÿè®¡ï¼š
           - æ‰¹é‡æ”¶å–ï¼š${stats.batchCount}æ¬¡ï¼ŒæˆåŠŸç‡ï¼š${stats.batchSuccess * 100 / stats.batchCount}%
           - é€ä¸ªæ”¶å–ï¼š${stats.singleCount}æ¬¡
           - æ‰¹é‡å¹³å‡è€—æ—¶ï¼š${stats.avgBatchTime}ms
           - é€ä¸ªå¹³å‡è€—æ—¶ï¼š${stats.avgSingleTime}ms
       """.trimIndent())
   }
   ```

---

### 1.4 ä¼˜åŒ–å»ºè®®

#### å»ºè®®1: æ™ºèƒ½æ‰¹é‡å¤§å°

```kotlin
// æ–°å¢é…ç½®
private var adaptiveBatchSize: BooleanModelField? = null

modelFields.addField(
    BooleanModelField(
        "adaptiveBatchSize",
        "è‡ªé€‚åº”æ‰¹é‡å¤§å°",
        true
    ).also { adaptiveBatchSize = it }
)

// ä¼˜åŒ–é€»è¾‘
private fun collectEnergy(...) {
    if (isBatchCollect) {
        val batchSize = if (adaptiveBatchSize!!.value) {
            calculateOptimalBatchSize(detectNetworkQuality(), bubbleIds.size)
        } else {
            MAX_BATCH_SIZE
        }
        
        var i = 0
        while (i < bubbleIds.size) {
            val subList = bubbleIds.subList(i, min(i + batchSize, bubbleIds.size))
            collectBatch(subList)
            i += batchSize
        }
    }
}
```

#### å»ºè®®2: å¤±è´¥é™çº§æœºåˆ¶

```kotlin
private fun collectBatchWithFallback(subList: List<Long>, userId: String) {
    try {
        // å°è¯•æ‰¹é‡æ”¶å–
        val startTime = System.currentTimeMillis()
        collectBatch(subList)
        val duration = System.currentTimeMillis() - startTime
        
        // è®°å½•æˆåŠŸç»Ÿè®¡
        recordBatchSuccess(duration)
        
    } catch (e: BatchCollectException) {
        Log.record(TAG, "æ‰¹é‡æ”¶å–å¤±è´¥ï¼Œé™çº§ä¸ºé€ä¸ªæ”¶å–: ${e.message}")
        
        // é™çº§ä¸ºé€ä¸ªæ”¶å–
        for (id in subList) {
            try {
                collectSingle(id, userId)
            } catch (e2: Exception) {
                Log.error(TAG, "é€ä¸ªæ”¶å–ä¹Ÿå¤±è´¥: $id")
            }
        }
    }
}
```

#### å»ºè®®3: ç½‘ç»œè´¨é‡æ£€æµ‹

```kotlin
enum class NetworkQuality {
    EXCELLENT, GOOD, POOR, UNKNOWN
}

private fun detectNetworkQuality(): NetworkQuality {
    try {
        // æ–¹æ¡ˆ1: åŸºäºæœ€è¿‘RPCè°ƒç”¨å»¶è¿Ÿ
        val recentLatencies = getRecentRpcLatencies(5)
        val avgLatency = recentLatencies.average()
        
        return when {
            avgLatency < 200 -> NetworkQuality.EXCELLENT
            avgLatency < 500 -> NetworkQuality.GOOD
            avgLatency < 1000 -> NetworkQuality.POOR
            else -> NetworkQuality.UNKNOWN
        }
        
        // æ–¹æ¡ˆ2: åŸºäºç³»ç»Ÿç½‘ç»œç±»å‹
        val cm = context.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager
        val networkInfo = cm.activeNetworkInfo
        
        return when (networkInfo?.type) {
            ConnectivityManager.TYPE_WIFI -> NetworkQuality.EXCELLENT
            ConnectivityManager.TYPE_MOBILE -> {
                when (networkInfo.subtype) {
                    TelephonyManager.NETWORK_TYPE_LTE -> NetworkQuality.GOOD
                    else -> NetworkQuality.POOR
                }
            }
            else -> NetworkQuality.UNKNOWN
        }
    } catch (e: Exception) {
        return NetworkQuality.UNKNOWN
    }
}
```

---

## 2. Android 11åå°å”¤é†’æ–¹æ¡ˆ

### 2.1 é—®é¢˜åˆ†æ

Android 11å¼•å…¥äº†ä¸¥æ ¼çš„åå°é™åˆ¶ï¼š

1. **åå°åº”ç”¨æ— æ³•å¯åŠ¨Activity**
2. **ç²¾ç¡®é—¹é’Ÿå—é™** (éœ€è¦SCHEDULE_EXACT_ALARMæƒé™)
3. **WorkManageræœ€å°é—´éš”15åˆ†é’Ÿ**
4. **å‰å°æœåŠ¡é™åˆ¶**

### 2.2 XQuickEnergyå‚è€ƒæ–¹æ¡ˆ

æŸ¥çœ‹XQuickEnergyé¡¹ç›®ï¼Œå‘ç°å®ƒæ²¡æœ‰ä½¿ç”¨åå°å”¤é†’æœºåˆ¶ï¼Œè€Œæ˜¯ï¼š

1. **ä¾èµ–Xposed Hook**
   - Hookæ”¯ä»˜å®çš„ç”Ÿå‘½å‘¨æœŸ
   - æ”¯ä»˜å®å‰å°æ—¶è‡ªåŠ¨è§¦å‘

2. **æ— ç‹¬ç«‹åå°æœåŠ¡**
   - ä¸éœ€è¦AlarmManager
   - ä¸éœ€è¦WorkManager

3. **ç­–ç•¥**
   - ç”¨æˆ·æ‰“å¼€æ”¯ä»˜å®æ—¶è‡ªåŠ¨æ‰§è¡Œ
   - ä¸å¼ºåˆ¶åå°å”¤é†’

### 2.3 Sesame-TK3å½“å‰å®ç°

```kotlin
// CoroutineScheduler.kt
// ä½¿ç”¨åç¨‹ + AlarmManager
class CoroutineScheduler {
    private fun scheduleNextExecution() {
        val alarmManager = context.getSystemService(Context.ALARM_SERVICE) as AlarmManager
        
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
            // Android 12+ éœ€è¦æ£€æŸ¥æƒé™
            if (alarmManager.canScheduleExactAlarms()) {
                alarmManager.setExactAndAllowWhileIdle(...)
            }
        } else {
            alarmManager.setExactAndAllowWhileIdle(...)
        }
    }
}
```

### 2.4 æ¨èæ–¹æ¡ˆ

#### æ–¹æ¡ˆ1: å‰å°æœåŠ¡ + AlarmManagerï¼ˆæ¨èï¼‰

```kotlin
class EnergyCollectionService : Service() {
    
    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        // åˆ›å»ºå‰å°é€šçŸ¥
        val notification = createForegroundNotification()
        startForeground(NOTIFICATION_ID, notification)
        
        // è®¾ç½®ç²¾ç¡®é—¹é’Ÿ
        scheduleNextAlarm()
        
        return START_STICKY
    }
    
    private fun scheduleNextAlarm() {
        val alarmManager = getSystemService(AlarmManager::class.java)
        val intent = Intent(this, AlarmReceiver::class.java)
        val pendingIntent = PendingIntent.getBroadcast(
            this, 0, intent,
            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
        )
        
        val nextTime = calculateNextExecutionTime()
        
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
            if (alarmManager.canScheduleExactAlarms()) {
                alarmManager.setExactAndAllowWhileIdle(
                    AlarmManager.RTC_WAKEUP,
                    nextTime,
                    pendingIntent
                )
            } else {
                // è¯·æ±‚æƒé™
                requestExactAlarmPermission()
            }
        } else {
            alarmManager.setExactAndAllowWhileIdle(
                AlarmManager.RTC_WAKEUP,
                nextTime,
                pendingIntent
            )
        }
    }
    
    private fun createForegroundNotification(): Notification {
        val channel = NotificationChannel(
            CHANNEL_ID,
            "èƒ½é‡æ”¶å–æœåŠ¡",
            NotificationManager.IMPORTANCE_LOW
        )
        
        val notificationManager = getSystemService(NotificationManager::class.java)
        notificationManager.createNotificationChannel(channel)
        
        return NotificationCompat.Builder(this, CHANNEL_ID)
            .setContentTitle("èŠéº»ç²’è¿è¡Œä¸­")
            .setContentText("ä¸‹æ¬¡æ‰§è¡Œ: ${TimeUtil.getTimeStr(nextExecutionTime)}")
            .setSmallIcon(R.drawable.ic_notification)
            .setPriority(NotificationCompat.PRIORITY_LOW)
            .build()
    }
}
```

#### æ–¹æ¡ˆ2: Xposed Hook + æ— åå°ï¼ˆæœ€ç®€å•ï¼‰

```kotlin
// ä¸ä½¿ç”¨AlarmManagerï¼Œå®Œå…¨ä¾èµ–Xposed Hook
// Hookæ”¯ä»˜å®çš„Activityç”Ÿå‘½å‘¨æœŸ

@XposedHook
fun hookAlipayLifecycle() {
    XposedHelpers.findAndHookMethod(
        "com.alipay.mobile.framework.app.ui.BaseActivity",
        classLoader,
        "onResume",
        object : XC_MethodHook() {
            override fun afterHookedMethod(param: MethodHookParam) {
                // æ”¯ä»˜å®å‰å°æ—¶æ£€æŸ¥æ˜¯å¦éœ€è¦æ‰§è¡Œä»»åŠ¡
                if (shouldExecuteTask()) {
                    executeTask()
                }
            }
        }
    )
}
```

#### æ–¹æ¡ˆ3: WorkManagerï¼ˆä¸æ¨èï¼‰

```kotlin
// WorkManageræœ€å°é—´éš”15åˆ†é’Ÿï¼Œä¸é€‚åˆç²¾ç¡®å®šæ—¶
class EnergyCollectionWorker(context: Context, params: WorkerParameters) 
    : CoroutineWorker(context, params) {
    
    override suspend fun doWork(): Result {
        setForeground(getForegroundInfo())
        
        // æ‰§è¡Œèƒ½é‡æ”¶å–
        try {
            collectEnergy()
            return Result.success()
        } catch (e: Exception) {
            return Result.retry()
        }
    }
    
    override suspend fun getForegroundInfo(): ForegroundInfo {
        return ForegroundInfo(
            NOTIFICATION_ID,
            createNotification()
        )
    }
}

// è°ƒåº¦
fun scheduleWork() {
    val request = PeriodicWorkRequestBuilder<EnergyCollectionWorker>(
        15, TimeUnit.MINUTES  // æœ€å°15åˆ†é’Ÿ
    ).build()
    
    WorkManager.getInstance(context).enqueue(request)
}
```

---

## 3. åŠ¨æ€æ”¶å–é—´éš”ä¼˜åŒ–

### 3.1 å½“å‰é—®é¢˜

```kotlin
// å½“å‰å®ç°ï¼šå›ºå®š5åˆ†é’Ÿé—´éš”
private const val FULL_COLLECT_INTERVAL_MS = 5 * 60 * 1000L

suspend fun executeFullCollection(antForest: AntForest) {
    if (!shouldExecuteFullCollection()) return
    // ...
}
```

**é—®é¢˜**:
1. ä¸è€ƒè™‘èƒ½é‡æˆç†Ÿæ—¶é—´
2. ä¸è€ƒè™‘å½“å‰ä»»åŠ¡æ‰§è¡Œæƒ…å†µ
3. å›ºå®šé—´éš”å¯èƒ½é”™è¿‡å…³é”®æ—¶æœº

### 3.2 æ”¹è¿›æ–¹æ¡ˆ

#### æ–¹æ¡ˆ1: åŸºäºèƒ½é‡æˆç†Ÿæ—¶é—´åŠ¨æ€è°ƒæ•´

```kotlin
object DynamicCollectionScheduler {
    
    /**
     * è®¡ç®—ä¸‹æ¬¡æ”¶å–æ—¶é—´
     */
    fun calculateNextCollectionTime(): Long {
        val now = System.currentTimeMillis()
        
        // 1. è·å–æœ€è¿‘çš„è¹²ç‚¹ä»»åŠ¡æ—¶é—´
        val nextWaitingTask = EnergyWaitingManager.getNextTaskTime()
        
        // 2. è·å–å¥½å‹èƒ½é‡æˆç†Ÿæ—¶é—´
        val nextFriendEnergy = getFriendNextEnergyTime()
        
        // 3. è·å–è‡ªå·±èƒ½é‡æˆç†Ÿæ—¶é—´
        val nextSelfEnergy = getSelfNextEnergyTime()
        
        // 4. å–æœ€æ—©çš„æ—¶é—´
        val candidates = listOf(nextWaitingTask, nextFriendEnergy, nextSelfEnergy)
            .filter { it > now }
        
        return if (candidates.isNotEmpty()) {
            // æå‰5ç§’æ‰§è¡Œ
            candidates.minOrNull()!! - 5000
        } else {
            // æ²¡æœ‰å·²çŸ¥æ—¶é—´ï¼Œé»˜è®¤5åˆ†é’Ÿå
            now + 5 * 60 * 1000
        }
    }
    
    /**
     * æ™ºèƒ½æ”¶å–å¾ªç¯
     */
    suspend fun smartCollectionLoop() {
        while (isActive) {
            try {
                // æ‰§è¡Œæ”¶å–
                executeCollection()
                
                // è®¡ç®—ä¸‹æ¬¡æ‰§è¡Œæ—¶é—´
                val nextTime = calculateNextCollectionTime()
                val waitDuration = nextTime - System.currentTimeMillis()
                
                Log.record(TAG, "ä¸‹æ¬¡æ”¶å–æ—¶é—´: ${TimeUtil.getTimeStr(nextTime)}, ç­‰å¾…${waitDuration/1000}ç§’")
                
                // ç­‰å¾…
                delay(waitDuration)
                
            } catch (e: Exception) {
                Log.printStackTrace(TAG, "æ™ºèƒ½æ”¶å–å¼‚å¸¸", e)
                delay(60 * 1000) // å‡ºé”™ç­‰å¾…1åˆ†é’Ÿ
            }
        }
    }
}
```

#### æ–¹æ¡ˆ2: åŸºäºæ—¶é—´æ®µçš„åŠ¨æ€ç­–ç•¥

```kotlin
/**
 * æ ¹æ®æ—¶é—´æ®µè°ƒæ•´æ”¶å–é¢‘ç‡
 */
fun calculateIntervalByTimeOfDay(): Long {
    val hour = Calendar.getInstance().get(Calendar.HOUR_OF_DAY)
    
    return when (hour) {
        in 7..8 -> 2 * 60 * 1000L      // 7-8ç‚¹ï¼š2åˆ†é’Ÿï¼ˆé«˜å³°æœŸï¼‰
        in 12..13 -> 3 * 60 * 1000L    // 12-13ç‚¹ï¼š3åˆ†é’Ÿï¼ˆåˆä¼‘æœŸï¼‰
        in 18..19 -> 2 * 60 * 1000L    // 18-19ç‚¹ï¼š2åˆ†é’Ÿï¼ˆæ™šé«˜å³°ï¼‰
        in 22..23 -> 10 * 60 * 1000L   // 22-23ç‚¹ï¼š10åˆ†é’Ÿï¼ˆç¡å‰ï¼‰
        in 0..6 -> 30 * 60 * 1000L     // 0-6ç‚¹ï¼š30åˆ†é’Ÿï¼ˆæ·±å¤œï¼‰
        else -> 5 * 60 * 1000L         // å…¶ä»–æ—¶é—´ï¼š5åˆ†é’Ÿ
    }
}
```

#### æ–¹æ¡ˆ3: åŸºäºå†å²æ•°æ®çš„é¢„æµ‹

```kotlin
/**
 * åŸºäºå†å²æ•°æ®é¢„æµ‹èƒ½é‡æˆç†Ÿæ—¶é—´
 */
class EnergyPredictionEngine {
    
    private val friendEnergyHistory = ConcurrentHashMap<String, MutableList<Long>>()
    
    /**
     * è®°å½•å¥½å‹èƒ½é‡æˆç†Ÿæ—¶é—´
     */
    fun recordEnergyTime(userId: String, timestamp: Long) {
        val history = friendEnergyHistory.getOrPut(userId) { mutableListOf() }
        history.add(timestamp)
        
        // åªä¿ç•™æœ€è¿‘10æ¬¡è®°å½•
        if (history.size > 10) {
            history.removeAt(0)
        }
    }
    
    /**
     * é¢„æµ‹ä¸‹æ¬¡èƒ½é‡æˆç†Ÿæ—¶é—´
     */
    fun predictNextEnergyTime(userId: String): Long? {
        val history = friendEnergyHistory[userId] ?: return null
        if (history.size < 3) return null
        
        // è®¡ç®—å¹³å‡é—´éš”
        val intervals = mutableListOf<Long>()
        for (i in 1 until history.size) {
            intervals.add(history[i] - history[i-1])
        }
        
        val avgInterval = intervals.average().toLong()
        val lastTime = history.last()
        
        return lastTime + avgInterval
    }
    
    /**
     * è·å–æ‰€æœ‰å¥½å‹çš„é¢„æµ‹æ—¶é—´
     */
    fun getAllPredictedTimes(): List<Long> {
        return friendEnergyHistory.keys
            .mapNotNull { predictNextEnergyTime(it) }
            .filter { it > System.currentTimeMillis() }
            .sorted()
    }
}
```

---

## 4. å®æ–½å»ºè®®

### 4.1 ä¼˜å…ˆçº§æ’åº

| ä¼˜å…ˆçº§ | ä»»åŠ¡ | éš¾åº¦ | é¢„è®¡æ—¶é—´ | æ•ˆæœ |
|--------|------|------|----------|------|
| P0 | ä¿®å¤.gitignore | â­ | 5åˆ†é’Ÿ | âœ…å·²å®Œæˆ |
| P0 | å›æ»šé”™è¯¯æäº¤ | â­ | 5åˆ†é’Ÿ | âœ…å·²å®Œæˆ |
| P1 | æ‰¾èƒ½é‡ä¸€é”®æ”¶å–ä¼˜åŒ– | â­â­ | 2å°æ—¶ | ğŸ”¥é«˜ |
| P2 | åŠ¨æ€æ”¶å–é—´éš” | â­â­â­ | 3å°æ—¶ | ğŸ”¥ä¸­ |
| P3 | Android 11åå°å”¤é†’ | â­â­â­â­ | 1å¤© | ğŸ”¥ä½ |

### 4.2 å®æ–½æ­¥éª¤

#### ç¬¬1æ­¥: æ‰¾èƒ½é‡ä¸€é”®æ”¶å–ä¼˜åŒ–ï¼ˆæ¨èç«‹å³å®æ–½ï¼‰

```kotlin
// 1. æ·»åŠ è‡ªé€‚åº”æ‰¹é‡å¤§å°é…ç½®
modelFields.addField(
    BooleanModelField("adaptiveBatchSize", "è‡ªé€‚åº”æ‰¹é‡å¤§å°", true)
        .also { adaptiveBatchSize = it }
)

// 2. å®ç°ç½‘ç»œè´¨é‡æ£€æµ‹
private fun detectNetworkQuality(): NetworkQuality { ... }

// 3. ä¼˜åŒ–æ‰¹é‡æ”¶å–é€»è¾‘
private fun collectEnergy(...) {
    val batchSize = if (adaptiveBatchSize!!.value) {
        calculateOptimalBatchSize(...)
    } else {
        MAX_BATCH_SIZE
    }
    // ...
}

// 4. æ·»åŠ å¤±è´¥é™çº§
try {
    collectBatch(subList)
} catch (e: Exception) {
    // é™çº§ä¸ºé€ä¸ªæ”¶å–
    collectSingleFallback(subList)
}
```

#### ç¬¬2æ­¥: åŠ¨æ€æ”¶å–é—´éš”ï¼ˆæ¨èæœ¬å‘¨å®Œæˆï¼‰

```kotlin
// 1. å®ç°åŸºäºæ—¶é—´æ®µçš„åŠ¨æ€é—´éš”
fun calculateInterval(): Long {
    val hour = Calendar.getInstance().get(Calendar.HOUR_OF_DAY)
    return when (hour) {
        in 7..8 -> 2 * 60 * 1000L
        // ...å…¶ä»–æ—¶é—´æ®µ
    }
}

// 2. é›†æˆåˆ°æ”¶å–å¾ªç¯
suspend fun smartCollectionLoop() {
    while (isActive) {
        executeCollection()
        val interval = calculateInterval()
        delay(interval)
    }
}
```

#### ç¬¬3æ­¥: Android 11åå°å”¤é†’ï¼ˆå¯é€‰ï¼‰

```kotlin
// é‡‡ç”¨æ–¹æ¡ˆ1: å‰å°æœåŠ¡ + AlarmManager
// æˆ–é‡‡ç”¨æ–¹æ¡ˆ2: å®Œå…¨ä¾èµ–Xposed Hookï¼ˆæ›´ç®€å•ï¼‰

// å»ºè®®ï¼šå…ˆæµ‹è¯•æ–¹æ¡ˆ2ï¼Œå¦‚æœä¸æ»¡è¶³éœ€æ±‚å†å®ç°æ–¹æ¡ˆ1
```

### 4.3 æµ‹è¯•è®¡åˆ’

1. **å•å…ƒæµ‹è¯•**
   ```kotlin
   @Test
   fun testAdaptiveBatchSize() {
       val size = calculateOptimalBatchSize(NetworkQuality.EXCELLENT, 20)
       assertEquals(10, size)
   }
   ```

2. **é›†æˆæµ‹è¯•**
   - åœ¨ä¸åŒç½‘ç»œç¯å¢ƒä¸‹æµ‹è¯•
   - éªŒè¯å¤±è´¥é™çº§æœºåˆ¶
   - æ£€æŸ¥æ—¥å¿—è¾“å‡º

3. **æ€§èƒ½æµ‹è¯•**
   - å¯¹æ¯”ä¼˜åŒ–å‰åçš„æ”¶å–è€—æ—¶
   - ç»Ÿè®¡æˆåŠŸç‡
   - ç›‘æ§å†…å­˜å ç”¨

---

## ğŸ“ æ€»ç»“

### å·²å®Œæˆ
- âœ… .gitignoreä¿®æ”¹ï¼ˆå…è®¸è®¿é—®æ—¥å¿—ï¼‰
- âœ… å›æ»šé”™è¯¯æäº¤
- âœ… æ‰¾èƒ½é‡ä¸€é”®æ”¶å–åŠŸèƒ½åˆ†æ
- âœ… Android 11åå°å”¤é†’æ–¹æ¡ˆç ”ç©¶
- âœ… åŠ¨æ€æ”¶å–é—´éš”è®¾è®¡

### å»ºè®®ç«‹å³å®æ–½
1. **æ‰¾èƒ½é‡ä¸€é”®æ”¶å–ä¼˜åŒ–** - æ•ˆæœæ˜¾è‘—ï¼Œå®æ–½ç®€å•
2. **åŠ¨æ€æ”¶å–é—´éš”** - æå‡ç”¨æˆ·ä½“éªŒ

### å»ºè®®æš‚ç¼“å®æ–½
1. **Android 11åå°å”¤é†’** - å¤æ‚åº¦é«˜ï¼Œå¯å…ˆä½¿ç”¨Xposed Hookæ–¹æ¡ˆ

### å…³é”®åŸåˆ™
- ğŸ¢ å°æ­¥è¿­ä»£ï¼Œæ¯æ¬¡åªæ”¹ä¸€å¤„
- âœ… ç«‹å³æµ‹è¯•ç¼–è¯‘
- ğŸ“ è¯¦ç»†è®°å½•ä¿®æ”¹
- ğŸ”¬ å……åˆ†æµ‹è¯•éªŒè¯

---

**æ–‡æ¡£ç‰ˆæœ¬**: 1.0  
**æœ€åæ›´æ–°**: 2025-10-19 12:40
